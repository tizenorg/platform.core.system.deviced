#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <unistd.h>
#include <poll.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/eventfd.h>

#include <linux/usb/functionfs.h>
#include <systemd/sd-daemon.h>

#define FFS_PATH "/tmp/usb-host-test-ffs"

#define EP_IN_IDX 1
#define EP_OUT_IDX 2

#define MAX(a, b) ((a) > (b) ? (a) : (b))

#define report_error(...) do {			\
		fprintf(stderr, __VA_ARGS__);	\
		putchar('\n');			\
	} while (0)

char buf[512];

/* Close all ep files */
void cleanup_ffs(int *ep)
{
	int i;

	for (i = 0; i < 3; ++i)
		close(ep[i]);
}

/* Handle events generated by kernel and provided via ep0 */
int handle_ep0(int ep0, int *connected)
{
	struct usb_functionfs_event event;
	int ret;

	ret = read(ep0, &event, sizeof(event));
	if (!ret) {
		report_error("unable to read event from ep0");
		return -EIO;
	}

	switch (event.type) {
	case FUNCTIONFS_SETUP:
		/* stall for all setuo requests */
		if (event.u.setup.bRequestType & USB_DIR_IN)
			(void) write(ep0, NULL, 0);
		else
			(void) read(ep0, NULL, 0);
		break;

	case FUNCTIONFS_ENABLE:
		*connected = 1;
		break;

	case FUNCTIONFS_DISABLE:
		*connected = 0;
		break;

	default:
		break;
	}

	return 0;
}

/* main chat function */
void do_chat(int *ep)
{
	int connected = 0;
	int ret;

	while (1) {
		while (!connected) {
			ret = handle_ep0(ep[0], &connected);
			if (ret < 0)
				return;
		}
		while (connected) {
			ret = read(ep[EP_OUT_IDX], buf, sizeof(buf));
			if (ret < 0) {
				if (ret == -ECONNRESET) {
					printf("Connection lost.");
					break;
				}
				return;
			}

			ret = write(ep[EP_IN_IDX], buf, ret);
			if (ret < 0) {
				if (ret == -ECONNRESET) {
					printf("Connection lost.");
					break;
				}
				return;
			}

		}

	}
}

int main(int argc, char **argv)
{
	int ep[3];
	int i = 0;

	if (sd_listen_fds(0) < 3) {
		fprintf(stderr, "Expected endpoints not retrieved\n");
		return -1;
	}

	for (i = 0; i < 3; ++i)
		ep[i] = SD_LISTEN_FDS_START + i;

	do_chat(ep);
	cleanup_ffs(ep);

	return 0;
}
